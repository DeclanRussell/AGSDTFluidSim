<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Cuda SPH Fluid Simulation - Declan Russell: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="main_logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cuda SPH Fluid Simulation - Declan Russell
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">SPH fluid simulation that uses cuda optimizations and some neat shading techniques</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Cuda SPH Fluid Simulation - Declan Russell Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Cuda Smoothed Particle Hydrodynamics Report </h1>
<div class="image">
<img src="IntroFluidPic.png" alt="IntroFluidPic.png"/>
</div>
 <h1>Introduction </h1>
<p>The contents of this report follows the design and implimentation of a real time fluid simulation. This implimentation takes the form of a 3D Langrangian grid and takes advanteges of the speed of Nvidia's Cuda API to create a fast realistic fluid simulation. In the following sections you will find an explenation of maths used, optimisations made and the implimentation of this artifact.</p>
<h1>Smoothed Particle Hydrodynamics and Fluid Theory </h1>
<p>When implimenting fluid simulations there is an array of techniques in which you can use. Each of which have there own advantages and disadvanteges. The most prominent of these techniques are Eulerian and Langrangian.</p>
<ul>
<li>Eulerian Method Looks at fluid motion through specific locations in space. Space is devided up into cells which store attributes about the fluid in that location such as pressure, velocity and desity etc...<ul>
<li>Advanteges<ul>
<li>Performance determined by grid size not number of particles</li>
<li>Fast</li>
</ul>
</li>
<li>Disadvanteges<ul>
<li>Detail contrained to grid size</li>
<li>Simulation size limited to grid size</li>
</ul>
</li>
</ul>
</li>
<li>Langrangian Method Focuses on individual particles of the fluid. Each particle stores attributes about its own pressure, velocity and density.<ul>
<li>Advanteges<ul>
<li>Simulation size not limited.</li>
</ul>
</li>
<li>Disadvanteges<ul>
<li>Performance tied to number of particles</li>
<li>For a realistic simulation we need to have a lot of particles</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>For this implimentation I will be following the Langrangian method.</p>
<h2>Navier Stokes Equations </h2>
<p>Navier stokes equations mathematically model the behaviour of fluid. The they look at calculating forces apparent in the fluid and give us an acceleration with from the sum all these forces. Bellow is the Langrangian fluid equation for weakly compressible flow.<br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \rho\frac{du}{dt}=-\bigtriangledown\rho+\mu\bigtriangledown^2 u + f \]" src="form_0.png"/>
</p>
<p><br/>
 On the left of this equation you will see the greek symbol <img class="formulaInl" alt="$\rho$" src="form_1.png"/> which stands for the density of the of the fluid. This is multiplied by <img class="formulaInl" alt="$\frac{du}{dt}$" src="form_2.png"/> which is the excelleration of our particle at the next timestep. Now lets break down the three componts on the right hand side of the equation.<br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ -\bigtriangledown\rho \]" src="form_3.png"/>
</p>
<p><br/>
 This term represents the gradient of pressure of our particle. Giving the direction that the pressure is in and the magnitude of this pressure<br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mu\bigtriangledown^2 u \]" src="form_4.png"/>
</p>
<p><br/>
This term represents the viscosity force acting upon our particle. <img class="formulaInl" alt="$\mu$" src="form_5.png"/> Being a scaler coefficient that can be set by the user to increase of decrease the viscosity force acting upon our fluid.<br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f \]" src="form_6.png"/>
</p>
<p><br/>
Our third and final term in this formulae represents any external forces acting upon our fluid. This could be anything from gravity, suface tension or any other forces you may need to interact with our fluid.</p>
<h2>Smoothed Particle Hydrodynamics </h2>
<p>Smoothed particle hydrodynamics is a technique that provides a collection of approximation formulae to solve our Navier Stokes equations. It focuses on scaling the forces in our Navier Stokes equation based on the distance between particles. Closer particles will have a much higher influence on our forces than particles further away. To do this we will specify a wighting kernel which I will specify later.</p>
<h2>Calculating our forces </h2>
<h2>Density </h2>
<p>As you can see from our Navier Stokes equations every force must be devided by the particles density to calculate the acceleration therefore the first force we must calculate must be the density of our particles. To do this we use the formulae bellow.<br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \rho(x_i)= \sum\limits_{j}m_j W_{default}(x_i-x_j,h) \]" src="form_32.png"/>
</p>
<p><br/>
 This formulae represents the sum of <img class="formulaInl" alt="$m$" src="form_8.png"/> which is the mass of our neightbouring particle. In our simluation our mass will be a constant with all particles having the same mass. This is then multiplied by function <img class="formulaInl" alt="$W$" src="form_18.png"/> which is our weighting kernel. More on how we calculate that later.</p>
<h2>Pressure Gradient </h2>
<p>Once we have our the densities of our particles calulated we can now move on to computing our pressure gradient. To do this firstly however we must calculate the pressure per particle in our simulation. This is computed with the following equation,<br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ p_i = k(\rho_i - \rho_0) \]" src="form_17.png"/>
</p>
<p><br/>
 Here we have variable <img class="formulaInl" alt="$k$" src="form_13.png"/> which is the gas constant of our fluid and will be set by the user depending on their desired fluid behaviour. <img class="formulaInl" alt="$\rho_i$" src="form_14.png"/> is the density of the particle that we are calcuating the pressure for and <img class="formulaInl" alt="$\rho_0$" src="form_15.png"/> is the rest density of our fluid. This is also a constant that the use will set by the user depending on their desired fluid behaviour. Now that we have our pressure per particle, we can use this to to compute our pressure gradient function,<br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_i^{pressure} = -\sum\limits_{i\neq j}p_j\frac{m_j}{\rho_j}\bigtriangledown W_{pressure}(x_i-x_j,h) \]" src="form_33.png"/>
</p>
<p><br/>
The formulae above represents the summation of particle properties <img class="formulaInl" alt="$j$" src="form_19.png"/> when <img class="formulaInl" alt="$j$" src="form_19.png"/> is not equal to <img class="formulaInl" alt="$i$" src="form_20.png"/>. The variable <img class="formulaInl" alt="$m_j$" src="form_9.png"/> is our particle mass, <img class="formulaInl" alt="$\rho_j$" src="form_10.png"/> is the density of our particle which we calculated using the equation in the previous section and <img class="formulaInl" alt="$W$" src="form_18.png"/> is our pressure weighting kernel which I will discuss later. However there is a problem when using this equation. The pressure force calculated is not symetrical as particle <img class="formulaInl" alt="$i$" src="form_20.png"/> only uses the the pressure at particle <img class="formulaInl" alt="$j$" src="form_19.png"/> to compute the pressure gradient. This problem can be solved however by using an different proposed equation [MJ92], </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_i^{pressure} = -\sum\limits_{i\neq j}(\frac{p_i}{\rho_i^2} + \frac{p_j}{\rho_j^2})m_j\bigtriangledown W_{pressure}(x_i-x_j,h) \]" src="form_35.png"/>
</p>
<h2>Viscosity Force </h2>
<p>Next we can calculate our viscosity force, the larger this force is the more it gives the fluid a thicker or stickier appearence. An example of a very viscous fluid would be syrup. To calculate this force we use the following equation, </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_i^{viscosity} = \mu\sum\limits_{i\neq j}(u_j-u_i)\bigtriangledown^2 W_{viscosity}(x_i-x_j,h) \]" src="form_36.png"/>
</p>
<p><br/>
In this equation we have one more unknown <img class="formulaInl" alt="$\mu$" src="form_5.png"/>, this represents the viscosity force. This is a scaler value set by the user to for the desired visocity influence on the fluid. Also you may notice that this formulae also contains a third weighting kernel which will be explained in the next section.</p>
<h2>Other forces </h2>
<p>Finally our final unknown is <img class="formulaInl" alt="$f$" src="form_37.png"/>. For this implimentation <img class="formulaInl" alt="$f$" src="form_37.png"/> will only represent gravity which we will assume is a constant 9.8m/s in the negative y direction. However for future work this can be extented to also include any other forces you may want to include such as surface tension or some kind of interaction forces.</p>
<h2>Weighting kernels </h2>
<p>As mentioned in the previous sections all our force equations use a weighting kernel which scales the force value calculated based on the distance particles are from each other. The first of these kernels we encountered was the function <img class="formulaInl" alt="$W_{default}$" src="form_38.png"/> which can be denoted,<br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \newcommand{\twopartdef}[4] { \left\{ \begin{array}{ll} #1 &amp; \mbox{if } #2 \\ #3 &amp; \mbox{if } #4 \end{array} \right. } W_{default}(r,h) = \frac{315}{64\pi h^9}\twopartdef{(h^2-||r||^2)^3}{0\leq ||r|| <h}{0}{||r||>h} \]" src="form_40.png"/>
</p>
<p>In this equation <img class="formulaInl" alt="$r$" src="form_41.png"/> is equivilent to vector from our neighbour particle to our current particle. The letter <img class="formulaInl" alt="$h$" src="form_42.png"/> is the smoothing length of our equation. This variable is set before the simulation is run and will affect the behaviour of our fluid.<br/>
The above weighting kernel will look like this when assuming that the soomthing length is 1,<br/>
</p>
<div class="image">
<img src="DefaultWK.png" alt="DefaultWK.png"/>
<div class="caption">
Default weighting kernel with smoothing length 1</div></div>
<p> This smoothing kernel is sutible for use on our density calculations but however will not be suitible for when we calculate our pressure. This is due to the gradient of the function tending to 0 as the distance of our particles tends to 0. To use this weighting kernel would create clustering of our particles. Ideally we would want our pressure kernel to continually get larger as our distance approaches 0 and is at the point of highest pressure. This is solved in [MM03] with their proposed "Spikey" kernel. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ W_{pressure}(r,h) = W_{spikey}(r,h) = -\frac{45}{\pi h^6} \frac{r}{||r||}(h-||r||)^2 \]" src="form_43.png"/>
</p>
<p>Again assuming that our smoothing length <img class="formulaInl" alt="$h$" src="form_42.png"/> is 1 our smoothing kernel will look like,<br/>
</p>
<div class="image">
<img src="PressureWK.png" alt="PressureWK.png"/>
<div class="caption">
Pressure weighting kernel with smoothing length 1</div></div>
<p> Notice how our kernel now tends to infinity due to our division of the length of <img class="formulaInl" alt="$r$" src="form_41.png"/> solving our clustering problem.</p>
<p>Our final weighting kernel is for our viscosity term. Also proposed [MM03] is the following kernel,<br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ W_{viscosity}(r,h) = -\frac{45}{\pi h^6}r(h-||r||) \]" src="form_44.png"/>
</p>
<p> If is important to note that unlike the pressure weighting kernel, the values from our viscosity weighing are always positive. This is because the viscosity term acts as a damping force, if values were to become negative it would increase the energy of our particles.<br/>
Again assuming that our smoothing length <img class="formulaInl" alt="$h$" src="form_42.png"/> is 1 our smoothing kernel will look like,<br/>
</p>
<div class="image">
<img src="ViscosityWK.png" alt="ViscosityWK.png"/>
<div class="caption">
Viscosity weighting kernel with smoothing length 1</div></div>
 <h2>Integration Methods </h2>
<h2>Euler </h2>
<p>To update our particles position we must integrate our acceleration to calculate first our velocity and then our displacement. The most basic integration we can use is Euler integration which goes as follows,<br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ u = u + adt \]" src="form_45.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x = x + udt \]" src="form_46.png"/>
</p>
<p>We have four unknowns in these equations. <img class="formulaInl" alt="$x$" src="form_47.png"/>, <img class="formulaInl" alt="$u$" src="form_48.png"/> and <img class="formulaInl" alt="$a$" src="form_49.png"/> are our position, velocity and acceleration. Our final unknown <img class="formulaInl" alt="$dt$" src="form_50.png"/> is the timestep of our update. However the problem with this method is that as the simulation the chance of error when using these equations increases over time. These means the longer the simulation is running for the more inaccurate and unstable it will get. </p>
<h2>Leap Frog </h2>
<p>A more stable method to use is the Leap Frog method. This method uses future half step velocity and a previous half step velocity to calculate the position at the next half time step. This method proves much more stable than our Euler method. It is achieved with the equations below,<br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_{t+\frac{1}{2} \triangle t} = u_{t- \frac{1}{2} \triangle t} + \triangle t a_t \]" src="form_51.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_{t-\frac{1}{2} \triangle t} = u_0 - \frac{1}{2}\triangle t a_0 \]" src="form_52.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{t+\frac{1}{2} \triangle t} = x_t - \triangle tu_{t+\frac{1}{2} \triangle t} \]" src="form_53.png"/>
</p>
<p> Below is a graph comparing the error of Leap Frog compared to other popular integration techniques over time with a deliberately high timestep used.<br/>
</p>
<div class="image">
<img src="leapFrogGraph.png" alt="leapFrogGraph.png"/>
<div class="caption">
Comparison of Integration Techniques. Source: http://einstein.drexel.edu/courses/Comp_Phys/Integrators/leapfrog/</div></div>
<p>As you can see from the graph although the accuracy may drop the integration technique stays very stable over long periods of time.</p>
<h1>Optimisations </h1>
<h2>Spacial Hash </h2>
<p>When sampling neighbouring particles it it computationally inificient to sample all the particles in our scene. If every particle <img class="formulaInl" alt="$n$" src="form_54.png"/> samples every orther particle <img class="formulaInl" alt="$n$" src="form_54.png"/> then we reach an overall computational complexity of <img class="formulaInl" alt="$O(n^2)$" src="form_55.png"/> which means our simulation will get exponetially slower the more particles we simulate in our scene. Any particles outside our smoothing length are given an influence of 0 on our particle, this means we can exclude them from our calculations. Idealy we want to only sample a set number of particles within our smoothing length which we can accomplish this with the use of a spacial hash. This spacial hash will assign particles that are near each other a unique key. we can then use this key to identify the particles that we need to sample. If we choose the maximum number of particles to sample and keep that as a constant value this reduces our complexity to <img class="formulaInl" alt="$O(n)$" src="form_56.png"/> which is fast. For this implimentation I have used a very simple hash function,<br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ p_n = p/s_g \]" src="form_57.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ r = s_g/h \]" src="form_58.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ p_g = \lfloor p_n*r \rfloor \]" src="form_59.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ idx = p_{gx}*r^2 + p_{gy}*r +p_{gz} \]" src="form_60.png"/>
</p>
<p> Where <img class="formulaInl" alt="$p$" src="form_61.png"/> is our position, <img class="formulaInl" alt="$s_g$" src="form_62.png"/> is the dimention size of our hash grid and <img class="formulaInl" alt="$h$" src="form_42.png"/> is our smoothing length. <img class="formulaInl" alt="$r$" src="form_41.png"/> refers to the resolution of our grid. We compute it this way so that every cell in our hash is the size of our smoothing length and particles of this cell and neighbouring cells are likely to be within our smoothing length. This is visualised in the image bellow.<br/>
</p>
<div class="image">
<img src="HashCells.png" alt="HashCells.png"/>
<div class="caption">
Hash Cells Source: Mark Harris, CUDA Fluid Simulation in NVIDIA PhysX http://sa08.idav.ucdavis.edu/CUDA_physx_fluids.Harris.pdf</div></div>
<p>As you can see from the image above, neighbouring cells particles must be taken into account in our samples as they may still lie within the smoothing length of our particle. Finding neighbouring hash keys is fast though and can be computed in the following way,<br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ neighbour idx = idx + (dx*r^2 + dy*r + dz) \]" src="form_63.png"/>
</p>
<p> Where <img class="formulaInl" alt="$dx,dy$" src="form_64.png"/> and <img class="formulaInl" alt="$dz$" src="form_65.png"/> are the offset of the neighbour hash cell we desire.</p>
<h2>CUDA </h2>
<p>CUDA or Compute Unified Device Architecture is a parallel computing API create from Nvidia which allows you to take control of your GPU's parallel architecture. This is ideal for our fluid simulation as it gives us the ability to process all our particle calculations at the same time rather than if we were to do this on the CPU in serial. This gives us the ability to simulate a much larger number of particles in our simulation. In the following sections I will discuss the implimentation of this.</p>
<h2>CUDA implimentation </h2>
<p>Important things to take into account when programming on the GPU.<br/>
</p>
<ul>
<li>Copying from GPU to CPU is slow, preferably we want to keep everything on the GPU as much as possible.</li>
<li>Accessing global memory from the GPU is slow, we should keep this to a minumum as much as possible. <br/>
First of all we need to set up some buffers to make our implimentation posible. The buffers needed are</li>
<li>Position buffer, size of how many particles we have.</li>
<li>Velocity buffer, size of how many particles we have.</li>
<li>Hash key buffer, size of how many particles we have.</li>
<li>Cell Occupancy buffer, size of our hash table. This can be calculated from the resolution cubed.</li>
<li>Cell Index buffer, size of our hash table. <br/>
</li>
</ul>
<ol type="1">
<li>Hashing partilces<br/>
 The first thing we need to do is hash our particles to give them a key based on their position. To do this we assign a thread to for everyparticle. Now simply use the equation from the previous section to out put our hash keys into a new buffer.</li>
<li>Sort our particle data by hash key.<br/>
 This is important to reduce banking conflicts when accessing from the global memory of our GPU. Global memory copies are slow so we want to do as little of them as possible. When you tell a cuda kernal to access global memory the bus will also give you the data from contiguous memory locations aswell. So for speed improvements we need to keep our memory as contiguous as possible reducing the number of global memory copies we do. To achieve this sort we can simply use thrust, a library of prewritten cuda functions. Thrust has its own sort_by_key function which is perfectly suitible for our needs.</li>
<li>Count Cell Occupancy<br/>
 We need to know the cell occupancy to know how many particles are in each cell. This also helps use identify where our particles are stored in memory. To count the cell occupancy is fairly simple. We assign a thread for every entry in our hash key buffer and we increment the value in our Cell Occupancy buffer relative to this hash key. However it is important to know that to avoid race conditions between threads. To solve this we can use CUDA's atomic add function to do this. This uses a mutex to lock the memory address while it is being modified by the current thread.</li>
<li>Create our cell index buffer<br/>
 This will give us the particle index of particles that belong in our cell. To compute this we can just create a running total of all the entries in our cell occupancy buffer. Thrust can again be used as its exlusive_scan function does just this in paralell.</li>
<li>Fluid Solving Now we have all our buffers prepared we can use our navier stokes equations and solve for our new particle position.<ol type="a">
<li>Assign a block of threads to every cell in our hash table.</li>
<li>Load our neighbouring particle data into shared memory.<br/>
 As we need to access neighbour particle data a lot in our calculations accessing global memory multiple times is going to add a lot of overhead to our solver. In the GPU architecture however every block has its own shared memory which can be accessed by all threads in that block. This shared memory is considerably faster than accessing global memory. Therefore its more efficient for us to copy once from global memory into shared memory than continuously copy from global memory.</li>
<li>Assign every thread a particle.</li>
<li>Perform our calculations on each particle</li>
<li>Update particle positions</li>
</ol>
</li>
<li>Collision detection<br/>
 The collision detection in this implimentation is very simple. I simply assign every particle to a thread and perform AABB collision detection on every position. If it has collided with the collision object the position is simply pushed back and the velocity of the particle is flipped.</li>
</ol>
<h2>Reducing some arithmetic computation </h2>
<p>Threads on the GPU do not have as much arithmetic power when compared to the CPU. This means that arithmetic operations that we perfrom on the GPU will have an impact on overhead on each kernal launch. To improve this we want to limit the number of operations as much as we can. A good example of this is our weighting kernals, </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \newcommand{\twopartdef}[4] { \left\{ \begin{array}{ll} #1 &amp; \mbox{if } #2 \\ #3 &amp; \mbox{if } #4 \end{array} \right. } W_{default}(r,h) = \frac{315}{64\pi h^9}\twopartdef{(h^2-||r||^2)^3}{0\leq ||r|| <h}{0}{||r||>h} \]" src="form_40.png"/>
</p>
<p> Notice that during our simulation assuming that we dont regularly change our smoothing length then <img class="formulaInl" alt="$\frac{315}{64\pi h^9}$" src="form_66.png"/> will remain constant. It actually become more efficient if we precalculate this on the CPU and load it in as a paramiter to our CUDA kernal. We can see another example in our pressure kernal,<br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_i^{pressure} = -\sum\limits_{i\neq j}(\frac{p_i}{\rho_i^2} + \frac{p_j}{\rho_j^2})m_j\bigtriangledown W_{pressure}(x_i-x_j,h) \]" src="form_35.png"/>
</p>
<p> Throughout our sum loop <img class="formulaInl" alt="$\frac{p_i}{\rho_i^2}$" src="form_67.png"/> will be the same. Instead of recomputing this every loop we can just compute it once, store the value and use it when needed. Secondly our mass <img class="formulaInl" alt="$m_j$" src="form_9.png"/> is constant, this means we can move it out side our loop reducing our multiply operations to just 1 time rather than <img class="formulaInl" alt="$j$" src="form_19.png"/> times. Our final equation will look like this, </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ p1 = \frac{p_i}{\rho_i^2} \]" src="form_68.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_i^{pressure} = -m_j\sum\limits_{i\neq j}(p1 + \frac{p_j}{\rho_j^2})\bigtriangledown W_{pressure}(x_i-x_j,h) \]" src="form_69.png"/>
</p>
<p> Simplifications like this can be made to all our equations. </p>
<h2>CUDA Streams and Multiple Simulations </h2>
<p>Another optimisation that CUDA provides are streams. This allows you to launch CUDA operations with a chance of operations in different streams being run concurrently. For this implimentation I have used this when creating seperate fluid simulations at the same time. This technique could be explored in further research to improve on how we launch the kernals to update our fluid simulation. More information about CUDA streams here: <a href="http://on-demand.gputechconf.com/gtc-express/2011/presentations/StreamsAndConcurrencyWebinar.pdf">http://on-demand.gputechconf.com/gtc-express/2011/presentations/StreamsAndConcurrencyWebinar.pdf</a> </p>
<h2>Simulation Performance </h2>
<p>Bellow you can see a graph representing the simulation performance when simulating different quantities of particles. </p>
<div class="image">
<img src="UpdateTime.png" alt="UpdateTime.png"/>
</div>
<h1>Rendering </h1>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed May 6 2015 16:29:09 for Cuda SPH Fluid Simulation - Declan Russell by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
